<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Aldevar - Le Blog - QRQVB</title><link href="/" rel="alternate"></link><link href="feeds/qrqvb.atom.xml" rel="self"></link><id>/</id><updated>2010-02-02T07:00:00+01:00</updated><subtitle>Yet Another Blog</subtitle><entry><title>QRQVB : Protocole TCP</title><link href="2010/02/qrqvb-protocole-tcp.html" rel="alternate"></link><published>2010-02-02T07:00:00+01:00</published><updated>2010-02-02T07:00:00+01:00</updated><author><name>alain</name></author><id>tag:None,2010-02-02:2010/02/qrqvb-protocole-tcp.html</id><summary type="html">&lt;p&gt;Nouvelle QRQVB et pas des moindres, le protocole TCP (Transmission
Control Protocol, Protocole de Contrôle de Transmission). &amp;nbsp;Comme son
petit frère UDP, TCP se situe en couche 4 du &lt;a class="reference external" href="https://web.archive.org/web/20110919035256/http://blog.aldevar.fr/?p=232"&gt;modèle
OSI&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="caracteristique-de-tcp"&gt;
&lt;h2&gt;Caractéristique de TCP&lt;/h2&gt;
&lt;p&gt;TCP est bien plus compliqué qu’UDP examiné au &lt;a class="reference external" href="https://web.archive.org/web/20110919035256/http://blog.aldevar.fr/?p=493"&gt;chapitre
précédent&lt;/a&gt;.
Il apporte en contrepartie des …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;Nouvelle QRQVB et pas des moindres, le protocole TCP (Transmission
Control Protocol, Protocole de Contrôle de Transmission). &amp;nbsp;Comme son
petit frère UDP, TCP se situe en couche 4 du &lt;a class="reference external" href="https://web.archive.org/web/20110919035256/http://blog.aldevar.fr/?p=232"&gt;modèle
OSI&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="caracteristique-de-tcp"&gt;
&lt;h2&gt;Caractéristique de TCP&lt;/h2&gt;
&lt;p&gt;TCP est bien plus compliqué qu’UDP examiné au &lt;a class="reference external" href="https://web.archive.org/web/20110919035256/http://blog.aldevar.fr/?p=493"&gt;chapitre
précédent&lt;/a&gt;.
Il apporte en contrepartie des services beaucoup plus élaborés.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;TCP contient un mécanisme pour assurer &lt;strong&gt;le bon acheminement des
données&lt;/strong&gt;. Cette possibilité est absolument indispensable dès lors
que les applications doivent transmettre de gros volumes de données
de façon fiable. Cette fonction est assurée par un mécanisme
d’acquittement (ou accusé de réception). Les paquets de données sont
acquittés de bout en bout et non de point à point. C’est à dire que
ce sont les machines sources et machines de destinations qui
s’occupent de cela et non les routeurs qui se situent entre les 2.&lt;/li&gt;
&lt;li&gt;Le protocole TCP permet l’établissement d’un &lt;strong&gt;circuit virtuel&lt;/strong&gt;
entre les 2 machines qui échangent de l’information (Voir a ce propos
le &lt;a class="reference external" href="https://web.archive.org/web/20110919035256/http://blog.aldevar.fr/?p=528#comment-757"&gt;commentaire de
Guizmo.7&lt;/a&gt;).
On dit aussi que TCP &amp;nbsp;fonctionne en &lt;strong&gt;mode connecté&lt;/strong&gt; (par opposition
à UDP qui est en mode non connecté). En pratique, l’une des 2 machine
doit effectuer un appel que l’autre doit accepter. S’en suit une
discutions afin d’établir certains paramètres de communication. Une
fois les préliminaires terminés, les protocoles informent les
applications respectives que la connexion est établie et que le
transfert peut débuter. Durant le transfert, le dialogue entre les
protocoles continue, pour vérifier le bon acheminement des données.&lt;/li&gt;
&lt;li&gt;TCP a la capacité de &lt;strong&gt;mémoriser les données&lt;/strong&gt;. Les paquets pouvant
prendre chacun un chemin différent pour arriver à destination, il
arrive que ceux ci n’arrivent pas dans le bon ordre. Grâce à cette
capacité de mémorisation, TCP garde les paquets un certains temps et
les reconstitue lorsqu’ils sont tous arrivés afin de présenter les
données à l’application.&lt;/li&gt;
&lt;li&gt;TCP simule une connexion en &lt;strong&gt;«&amp;nbsp;full duplex&amp;nbsp;»&lt;/strong&gt;. Pour chacune des 2
machines en connexion, l’opération qui consiste à lire des données
peut s’effectuer indépendamment de celle qui consiste à en écrire.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="entete-tcp"&gt;
&lt;h2&gt;Entête TCP&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="/images/enteteTCP1.png"&gt;&lt;img alt="enteteTCP1" src="/images/enteteTCP1.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;L’entête TCP est codé sur 20 octets hors options.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Port Source (16 bits): Port utilisé par l’application sur la machine
source.&lt;/li&gt;
&lt;li&gt;Port Destination (16 bits): Port de destination.&lt;/li&gt;
&lt;li&gt;Numéro d’ordre (32 bits): Correspond au numéro du paquet. Cette
valeur permet de situer à quel endroit du flux de données le paquet,
qui est arrivé, doit se situer par rapport aux autres paquets.&lt;/li&gt;
&lt;li&gt;Numéro d’accusé de réception (32 bits):&amp;nbsp;Acquittement pour les paquets
reçus. Cette valeur signale le prochain numéro de paquet attendu. Par
exemple, si il vaut 1500, cela signifie que tous les datagrammes
&amp;lt;1500 ont été reçus&lt;/li&gt;
&lt;li&gt;Offset (4 bits): Le champ Offset est codé sur 4 bits et définit le
nombre de mots de 32 bits dans l’entête TCP. Ce champ indique donc où
les données commencent.&lt;/li&gt;
&lt;li&gt;Réservé (6 bits): Champ inutilisé actuellement. Il était à l’origine
prévu pour l’avenir. On peut dire aujourd’hui que ce champ restera
vide.&lt;/li&gt;
&lt;li&gt;Drapeaux (flags) (6×1 bit): Les drapeaux représentent des
informations supplémentaires :
URG: si ce drapeau est à 1 le paquet doit être traité de façon
urgente.
ACK: si ce drapeau est à 1 le paquet est un accusé de réception.
PSH (PUSH): si ce drapeau est à 1, le paquet fonctionne suivant la
méthode PUSH.
RST: si ce drapeau est à 1, la connexion est réinitialisée.
SYN: Le Flag TCP SYN indique une demande d’établissement de
connexion.
FIN: si ce drapeau est à 1 la connexion s’interrompt.&lt;/li&gt;
&lt;li&gt;Fenêtre (16 bits): Champ permettant de connaître le nombre d’octets
que le récepteur souhaite recevoir sans envoyer d’accusé de
réception.&lt;/li&gt;
&lt;li&gt;Somme de contrôle (Checksum ou CRC): La somme de contrôle est
réalisée en faisant la somme des champs de données de l’en-tête, afin
de pouvoir vérifier l’intégrité de l’en-tête&lt;/li&gt;
&lt;li&gt;Pointeur d’urgence (16 bits): Indique le numéro d’ordre à partir
duquel l’information devient urgente.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="etablissement-dune-connexion"&gt;
&lt;h2&gt;Établissement d’une connexion&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="/images/ConnectionTCP.png"&gt;&lt;img alt="ConnectionTCP" src="/images/ConnectionTCP.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Une ouverture de connexion TCP s’effectue en 3 temps.&lt;/p&gt;
&lt;p&gt;L’émetteur du premier paquet doit avoir connaissance du couple
&lt;strong&gt;`IP &amp;lt;https://web.archive.org/web/20110919035256/http://blog.aldevar.fr/?p=293&amp;gt;`__
: Port&lt;/strong&gt; de l’application de la machine réceptrice (par exemple, on
contact un serveur HTTP sur le port 80 qui lui est dédié). L’émetteur de
ce premier paquet est à l’origine de l’établissement du circuit virtuel.
C’est une attitude qualifiée de «&amp;nbsp;&lt;strong&gt;cliente&lt;/strong&gt;«&amp;nbsp;.&lt;/p&gt;
&lt;p&gt;Le récepteur du premier paquet accepte l’établissement de la connexion,
ce qui suppose qu’il était prêt à le faire avant que le client en prenne
l’initiative. C’est une attitude de «&amp;nbsp;&lt;strong&gt;serveur&lt;/strong&gt;«&amp;nbsp;.&lt;/p&gt;
&lt;p&gt;Le client envoie un segment comportant le drapeau SYN à 1. Le serveur
répond avec sa propre séquence (SYN = 1) mais il doit aussi acquitter le
paquet précédent, ce qu’il fait avec ACK. Le client répond alors avec un
acquittement de la séquence du serveur (ACK = 1).&lt;/p&gt;
&lt;p&gt;Une fois achevée cette phase appelée «&amp;nbsp;Three-way handshake&amp;nbsp;», les 2
applications sont en mesure d’échanger des données.&lt;/p&gt;
&lt;/div&gt;
</content><category term="QRQVB"></category></entry><entry><title>QRQVB : Les paquets UDP</title><link href="2009/12/qrqvb-les-paquets-udp.html" rel="alternate"></link><published>2009-12-29T11:23:00+01:00</published><updated>2009-12-29T11:23:00+01:00</updated><author><name>alain</name></author><id>tag:None,2009-12-29:2009/12/qrqvb-les-paquets-udp.html</id><summary type="html">&lt;p&gt;Suite de la Question Réseau Qui Va Bien, nouveau billet purement réseau
donc. Je comptais me lancer dans la description des paquets TCP, mais je
pense qu’il est plus intéressant de se pencher d’abord sur UDP avant
d’appréhender TCP.&lt;/p&gt;
&lt;p&gt;UDP (Pour &lt;em&gt;User Datagram Protocol&lt;/em&gt;) se situe dans …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Suite de la Question Réseau Qui Va Bien, nouveau billet purement réseau
donc. Je comptais me lancer dans la description des paquets TCP, mais je
pense qu’il est plus intéressant de se pencher d’abord sur UDP avant
d’appréhender TCP.&lt;/p&gt;
&lt;p&gt;UDP (Pour &lt;em&gt;User Datagram Protocol&lt;/em&gt;) se situe dans la couche 4 du &lt;a class="reference external" href="http://blog.devarieux.net/2009/08/qrqvb-le-modele-osi/"&gt;modèle
OSI&lt;/a&gt; (couche
transport). Pour rappel, au niveau de la couche 3 (IP), &lt;a class="reference external" href="http://blog.devarieux.net/2009/09/qrqvb-datagramme-ip/"&gt;les
datagrammes&lt;/a&gt;
sont routés d’une machine à une autre en fonction des adresses IP (en
fait, le routage se fait en fonction de l’adresse réseau, voir &lt;a class="reference external" href="http://blog.devarieux.net/2009/09/309/"&gt;QRQVB :
L’adresse IP&lt;/a&gt;). Lors de cette
opération de routage, aucune distinction n’est faite entre les
différents services pour lesquels ces paquets peuvent être destinés. Que
ce soit pour une connexion SSH (port 22) ou HTTP (port 80) ou autre, les
datagrammes IP sont tous indifféremment mélangés.&lt;/p&gt;
&lt;p&gt;La couche 4 du modèle OSI ajoute un mécanisme qui permet
l’identification du service &amp;nbsp;concerné. Plusieurs programmes de plusieurs
utilisateurs pouvant simultanément circuler sur le réseau, il est
indispensable de faire un tri entre les applications. Ici, l’idée est
d’associer la destination du paquet à une fonction. L’identification de
cette fonction ce fait à l’aide d’un chiffre nommé &lt;strong&gt;Port&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="section" id="en-tete-udp"&gt;
&lt;h2&gt;En tête UDP&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="/images/encaps.png"&gt;&lt;img alt="encaps" src="/images/encaps.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lors de l’étude des &lt;a class="reference external" href="qrqvb-datagramme-ip.html"&gt;datagramme
IP&lt;/a&gt;, nous
avions vu le contenu de l’entête du paquet (partie verte). Ici, nous
allons observer le contenu de l’entête du message (partie jaune) lorsque
l’on traite un p&amp;gt;aquet UDP.&lt;/p&gt;
&lt;p&gt;Le paquet UDP est composé de 8 octets.&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="/images/entete.png"&gt;&lt;img alt="entete" src="/images/entete.png" /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Les 2 premiers octets contiennent le port source&lt;/strong&gt;. Codé sur 16 bits
donc. C’est le numéro de port de l’émetteur du paquet. C’est aussi le
numéro de port sur lequel le destinataire doit envoyer sa réponse.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Les octets 3 et 4 stockent le port de destination.&lt;/strong&gt; C’est sur ce port
que sera remis le paquet lors de sa livraison à la machine ciblée.&lt;/p&gt;
&lt;p&gt;Le port étant un entier positif de 16 bits, on en déduit que les bornes
sont 0 – 65535 (2^16). Cependant, le port 0 n’est pas exploitable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Les octets 5 et 6 contiennent la longueur de l’entête UDP&lt;/strong&gt; et du
message. Sa longueur minimal est 8 (entête UDP avec 0 données à
transporter) et sa longueur maximal 2^16 = 65535 (64ko).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Les 2 derniers octets contiennent le cheksum&lt;/strong&gt;. C’est la somme de
contrôle de l’entête UDP et des données qui suivent.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ports-reserves"&gt;
&lt;h2&gt;Ports réservés&lt;/h2&gt;
&lt;p&gt;Toute machine qui utilise la pile TCP/IP se doit de connaitre un
certains nombre de services bien connus, aussi appelé «&amp;nbsp;well known port
number&amp;nbsp;» pour pouvoir dialoguer avec les autres machines sur internet.
Sur une machines Unix, cette liste est placée dans le fichier
&lt;strong&gt;*/etc/services*&lt;/strong&gt; et se doit d’être lisible par tous les utilisateurs
et toutes les applications. Voici un extrait du contenu de ce fichier :&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Nom             Port/Protocol     Commentaire

netstat        15/tcp
 qotd       17/tcp      quote
 msp        18/tcp      # message send protocol
 msp        18/udp
 chargen    19/tcp      ttytst source
 chargen    19/udp      ttytst source
 ftp-data   20/tcp
 ftp        21/tcp
 fsp        21/udp      fspd
 ssh        22/tcp      # SSH Remote Login Protocol
 ssh        22/udp
 telnet     23/tcp
 smtp       25/tcp      mail
 time       37/tcp      timserver
 time       37/udp      timserver
 rlp        39/udp      resource    # resource location
 nameserver 42/tcp      name        # IEN 116
 whois      43/tcp      nicname
 tacacs     49/tcp              # Login Host Protocol (TACACS)
 tacacs     49/udp
 re-mail-ck 50/tcp              # Remote Mail Checking Protocol
 re-mail-ck 50/udp
 domain     53/tcp              # name-domain server
 domain     53/udp
 mtp        57/tcp              # deprecated
 tacacs-ds  65/tcp              # TACACS-Database Service
 tacacs-ds  65/udp
 bootps     67/tcp              # BOOTP server
 bootps     67/udp
 bootpc     68/tcp              # BOOTP client
 bootpc     68/udp
 tftp       69/udp
 gopher     70/tcp              # Internet Gopher
 gopher     70/udp
 rje        77/tcp      netrjs
 finger     79/tcp
 www        80/tcp      http        # WorldWideWeb HTTP
 www        80/udp              # HyperText Transfer Protocol
&lt;/pre&gt;
&lt;p&gt;Les ports 1 à 1023 sont réservés aux « well known ports ». Ils ne
peuvent être utilisés que par des applications qui s’exécutent avec des
droits privilégiés (root). Les autres ports peuvent être utilisés
librement sans privilège particulier et sont en général employés par les
applications clientes. Par exemple, sur ma machine, en ce moment, mon
client IRC utilise le port 59175 pour communiquer avec le serveur irc
holmes.freenode.net.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mode-non-connecte"&gt;
&lt;h2&gt;Mode non connecté&lt;/h2&gt;
&lt;p&gt;Contrairement à TCP, UDP est conçu pour permettre un échange de données
entre 2 applications sans échange préliminaire. UDP est utilisé si les
données à transmettre n’ont pas besoin d’être fragmentées en plusieurs
paquet. La paquet est ainsi envoyé sans s’assurer qu’il arrive bien à
destination. UDP est appelé mode de transport non connecté par
opposition à TCP. Plus particulièrement, les paquets a destination d’une
application UDP sont conservés dans une pile de type FIFO. Si
l’application destinatrice ne les “consomme” pas assez rapidement, les
plus anciens paquets risquent d’être écrasés par les plus récents… Un
risque supplémentaire de perte de données.&lt;/p&gt;
&lt;p&gt;Nous verrons comment TCP peut palier à ce problème dans la prochaine
QRQVB&lt;/p&gt;
&lt;/div&gt;
</content><category term="QRQVB"></category></entry><entry><title>QRQVB : L'adresse IP</title><link href="2009/09/qrqvb-adresse-ip.html" rel="alternate"></link><published>2009-09-16T19:12:00+02:00</published><updated>2009-09-16T19:12:00+02:00</updated><author><name>alain</name></author><id>tag:None,2009-09-16:2009/09/qrqvb-adresse-ip.html</id><summary type="html">&lt;div class="section" id="definition"&gt;
&lt;h2&gt;Définition :&lt;/h2&gt;
&lt;p&gt;Une adresse IP identifie de manière unique une machine ainsi que le
réseau sur lequel elle est située. Chaque adresse est une série de 4
octets dont une partie correspond à l’&lt;strong&gt;identificateur du réseau&lt;/strong&gt;&amp;nbsp;et
l’autre partie à l’&lt;strong&gt;identificateur de la machine&lt;/strong&gt;.
|  Exemple d’adresse IP …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="definition"&gt;
&lt;h2&gt;Définition :&lt;/h2&gt;
&lt;p&gt;Une adresse IP identifie de manière unique une machine ainsi que le
réseau sur lequel elle est située. Chaque adresse est une série de 4
octets dont une partie correspond à l’&lt;strong&gt;identificateur du réseau&lt;/strong&gt;&amp;nbsp;et
l’autre partie à l’&lt;strong&gt;identificateur de la machine&lt;/strong&gt;.
|  Exemple d’adresse IP : 172.19.174.125.&lt;/p&gt;
&lt;p&gt;Concrètement, qu’est ce que cela signifie? En fait, puisque les machines
ne savent traiter qu’avec des nombres binaires (0 ou 1) l’adresse est
codée en binaire sur 4 octets. Sachant qu’un octet correspond à 8 bits,
cela nous donne, pour chaque octet 256 possibilités (2^8) pour une
valeur comprise en 0 et 255.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="allons-un-peu-plus-loin"&gt;
&lt;h2&gt;Allons un peu plus loin!&lt;/h2&gt;
&lt;p&gt;C’est bien sympa d’avoir une adresse, encore faut-il qu’on puisse m’y
contacter! On vient de voir dans la définition que l’adresse IP est
divisée en 2 sous parties :&amp;nbsp;&lt;strong&gt;l’identificateur de
réseau&lt;/strong&gt;&amp;nbsp;et&amp;nbsp;&lt;strong&gt;l’identificateur d’hôte&lt;/strong&gt;. C’est là qu’intervient le
masque de réseau. Alors puisque je ne suis pas fort en blablatage, je
vais plutôt vous montrer un exemple.
|  Voici une adresse IP : 192.168.1.15
|  Voici un masque de réseau : 255.255.255.0&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="/images/netmask1.png"&gt;&lt;img alt="netmask1" src="/images/netmask1.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;En fait, pour être plus précis, les bits se situant dans la partie de
l’identificateur réseau sont tous positionnés sur 1 et les bits de la
partie hôte sur 0. En procédant à une opération de ET logique entre
l’adresse IP et le masque de réseau, on trouve l’adresse réseau. Les
opérations de ET logique suivent cette règle :&lt;/p&gt;
&lt;pre class="literal-block"&gt;
0 ET 0 = 0
0 Et 1 = 0
1 ET 0 = 0
1 ET 1 = 1
&lt;/pre&gt;
&lt;p&gt;Grâce à cette adresse réseau, un routeur pourra déterminer quel chemin
doivent emprunter nos paquets IP. Pour bien comprendre ce système, nous
allons jouer un peu avec le binaire, même si je sais que ça va en
rebuter plus d’un :p&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="/images/binaire.png"&gt;&lt;img alt="binaire" src="/images/binaire.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Ceci est important puisque c’est de cette manière qu’on va pouvoir
déterminer le nombre maximal de machines qui peuvent appartenir à un
réseau. Il faut également savoir que sur 1 réseau, 2 adresses sont
réservées. L’adresse&amp;nbsp;&lt;strong&gt;‘bits hôte à 0′&lt;/strong&gt;&amp;nbsp;car c’est elle qui va définir
justement l’adresse de notre réseau, comme on vient de le voir, et
l’adresse&amp;nbsp;&lt;strong&gt;‘bits hôte à 1′&lt;/strong&gt;&amp;nbsp;car elle correspond à l’adresse de
diffusion (broadcast). L’adresse de broadcast est nécessaire pour
diffuser un message sur tout le réseau. Le message de ce genre le plus
classique est la requête&amp;nbsp;ARP. Celle ci permet à une machine de trouver
une autre machine sur le réseau en l’appelant.&lt;/p&gt;
&lt;p&gt;Voici un exemple de capture de trame avec wireshark :&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="/images/arp2.png"&gt;&lt;img alt="arp2" src="/images/arp2.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Le premier paquet est donc une requête ARP. La machine source envoie ce
message sur tout le réseau : ‘who has 192.168.1.51? &amp;nbsp;Tell 192.168.1.25′.
La machine qui a pour IP 192.168.1.51 envoie donc sa réponse directement
à 192.168.1.15 et lui dit que c’est l’adresse MAC 00:0a:78:9e:8a qui
possède cette IP.&amp;nbsp;Tout ça pour vous dire que l’adresse IP ‘bits hôte à
1′ est donc réservée pour ce type de message.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="dimensionnement-de-reseau"&gt;
&lt;h2&gt;Dimensionnement de réseau&lt;/h2&gt;
&lt;p&gt;Puisque le masque de réseau détermine le nombre maximal de machines sur
un réseau et que les adresses IP ne sont pas illimitées, on va pouvoir
travailler sur le dimensionnement du réseau en modifiant le masque. En
effet,&amp;nbsp;&lt;strong&gt;il est possible d’emprunter des bits à la partie hôte pour
les donner à la partie réseau&lt;/strong&gt;. Par exemple, le masque 255.255.255.0
permet d’avoir 256-2 = 254 hôtes différents sur le même réseau. Hors,
rares sont ceux qui disposent de 254 machines à interconnecter.&lt;/p&gt;
&lt;p&gt;Admettons que mon réseau possède l’ip 192.168.1.0 (totalement au
hasard!) de masque 255.255.255.0 . Je dispose de 5 machines à connecter
sur ce réseau, jamais plus.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Si je garde 1bit dans la partie hôte, je vais disposer de 2^1 = 2
hôtes possibles. &amp;nbsp;On vient de voir plus haut que 2 adresses sont
reservées sur le réseau, (sisi, rapellez vous, juste au dessus!).
Donc 2-2 = 0, ce qui me fait 0 hôte disponible.&lt;/li&gt;
&lt;li&gt;Si je garde 2 bits pour ma partie hôte, il va me rester (2^2)-2 = 2
hôtes possibles. Ce n’est toujours pas suffisant!!&lt;/li&gt;
&lt;li&gt;Si je garde 3 bits pour la partie hôtes, j’obtiens (3^2)-2 = 6 hôtes
possibles. Ouf!! j’ai assez de place pour caser mes machines. On va
donc construire notre masque de réseau en gardant ces 3 bits sur 0,
ce qui nous donne :&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;11111111.11111111.11111111.11111 &amp;nbsp;&amp;nbsp; 000&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Partie réseau &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;Partie hôte&lt;/div&gt;
&lt;div class="line"&gt;Ce qui, transformé en décimal nous donne un masque : 255.255.255.248.&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ce qu’on vient de faire ici, c’est de créer des sous réseaux du réseau
192.168.1.0. Plusieurs sous réseaux composé chacun de 8 adresses IP.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Sous réseau 1 : de 192.168.1.0 à 192.168.1.7 (avec 192.168.1.0 adresse de sous réseau et 192.168.1.7 adresse de broadcast)
Sous réseau 2 : de 192.168.1.8 (adresse du réseau) à 192.168.1.15 (adresse de broadcast)
Sous réseau 3 : de 192.168.1.16(adresse du réseau) à 192.168.1.23 (adresse de broadcast)
etc etc..
dernier sous réseau : de 192.168.1.248 (adresse de réseau) à 192.168.1.255 (adresse de broadcast)
&lt;/pre&gt;
&lt;p&gt;Voilà donc ce qui se cache derrière les adresses IP. Plus mon sous
réseau sera petit, moins j’aurais de broadcast sur ce réseau. Parce que
mine ça papote pas mal la dedans et ça a tendance à broadcaster dans
tous les sens. Malheureusement, le broadcast n’est pas gratuit. Il coûte
de la bande passante. Et quand la bande passante sature, on commence à
perdre des paquets.&lt;/p&gt;
&lt;p&gt;C’est pour ça qu’il est important, en entreprise en tout cas, de bien
calculer le dimensionnement de son réseau et l’adressage IP de
l’entreprise, sans oublier de prévoir que si l’entreprise s’agrandit, il
va falloir rajouter des hôtes sur certains sous réseaux et en plus
ajouter un nouveau sous réseau à notre entreprise pour y connecter un
nouveau bâtiment par exemple. Ça a vite tendance à tourner cacahuète si
on fait pas attention.&lt;/p&gt;
&lt;/div&gt;
</content><category term="QRQVB"></category><category term="ip"></category><category term="qrqvb"></category><category term="réseaux"></category></entry><entry><title>QRQVB : Datagramme IP</title><link href="2009/09/qrqvb-datagramme-ip.html" rel="alternate"></link><published>2009-09-16T11:07:00+02:00</published><updated>2009-09-16T11:07:00+02:00</updated><author><name>alain</name></author><id>tag:None,2009-09-16:2009/09/qrqvb-datagramme-ip.html</id><summary type="html">&lt;p&gt;Je vais tenter dans cet article de décortiquer un datagramme IP et
notamment son en-tête. Nous allons commencer par l’observation des
encapsulations des données suivant le &lt;a class="reference external" href="http://blog.devarieux.net/2009/08/qrqvb-le-modele-osi/"&gt;modèle
OSI&lt;/a&gt; que nous
avons étudié la dernière fois. Les données (couche application) sont
encapsulées dans un message (couche 4, transport) qui est …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Je vais tenter dans cet article de décortiquer un datagramme IP et
notamment son en-tête. Nous allons commencer par l’observation des
encapsulations des données suivant le &lt;a class="reference external" href="http://blog.devarieux.net/2009/08/qrqvb-le-modele-osi/"&gt;modèle
OSI&lt;/a&gt; que nous
avons étudié la dernière fois. Les données (couche application) sont
encapsulées dans un message (couche 4, transport) qui est lui même
encapsulé dans un paquet (couche 3, réseau), lui même encapsulé dans une
trame (couche 2, liaison). Rien ne vaut un bon dessin pour
comprendre.&lt;a class="reference external" href="/images/encaps.png"&gt;&lt;img alt="encaps" src="/images/encaps.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Aujourd’hui, on va donc s’intéresser à ce que contient le petit carré
vert lorsque le paquet est un paquet IP.&lt;/p&gt;
&lt;p&gt;Cet en-tête est codé par défaut sur 20 octets. Nous allons donc nous
appliquer à décrypter le contenu de chacun de ses octets. J’ai fait pour
cela un schéma pas terrible mais qui me servira de support pour les
explications :p.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="/images/entete1.png"&gt;&lt;img alt="entete1" src="/images/entete1.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Le premier octet contient 2 informations.&lt;/strong&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;La première est la version du protocole utilisé, codée sur 4 bits.
pour le protocole IPv4, on utilisera le code 0100 qui correspond
au 4 décimal. Pour IPv6, c’est 0110 (6 décimal).&lt;/li&gt;
&lt;li&gt;La seconde information, codée également sur 4 bits contient l’IHM.
C’est la longueur, en mot de 32bits (4 octets), de l’en-tête du
datagramme. Par défaut, ces bits sont positionnés sur 0101, ce qui
correspond au 5 décimal, ce qui est logique pour un en-tête par
défaut de 20 octets.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Le deuxième octet est le TOS (type of service)&lt;/strong&gt; et va définir la
manière dont le datagramme doit être traité. Il se décompose lui
aussi en 2 :&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;3 bits pour la priorité à donner au datagramme (0 à 7)&lt;/li&gt;
&lt;li&gt;4 bits qui définissent chacun une option activée ou pas (1 option
activée, 0 option desactivée)&lt;ul&gt;
&lt;li&gt;1er bit : D → Positionné sur 1 pour privilégier le délai
d’acheminement&lt;/li&gt;
&lt;li&gt;2ème bit : T →&amp;nbsp;Positionné sur 1 pour privilégier le débit&lt;/li&gt;
&lt;li&gt;3ème bit : R →&amp;nbsp;Positionné sur 1 pour privilégier la fiabilité&lt;/li&gt;
&lt;li&gt;4ème bit : C → Positionné sur 1 pour privilégier le coût&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1 bit qui ne contient aucune information. Il est appelé MBZ pour
Must Be Zero. comme son nom l’indique, ce bit doit être positionné
sur 0.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Les 3ème et 4ème octets contiennent le champ Longueur Totale (Total
Lenght)&lt;/strong&gt;. Codé sur 16 bits, il contient la taille, en octet, du
datagramme complet (en-tête + données). On en déduit donc que la
longueur totale du paquet ne peut dépasser 65535 octets. Grâce à
cette valeur, on peut calculer la taille des données :&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;longueur données = Longueur totale – (IHM x 4)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Les 5ème et 6ème octets contiennent le champ Identification&lt;/strong&gt;.
Celui ci intervient lors du ré-assemblage des paquets pour
reconstituer les données lorsque celles ci sont fragmentées.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Les 7ème et 8ème octets contiennent 2 informations.&lt;/strong&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;3 bits correspondent au champ &lt;strong&gt;flag&lt;/strong&gt;. Il sert a déterminer
l’état de fragmentation.&lt;ul&gt;
&lt;li&gt;1er bit : Réservé, il doit être sur 0&lt;/li&gt;
&lt;li&gt;2ème bit : Don’t Fragment. Indique si la fragmentation est
autorisée.&lt;/li&gt;
&lt;li&gt;3ème bit : More Fragment. Positionné sur 1 il signifie que ce
datagramme n’est pas le dernier fragment.&lt;/li&gt;
&lt;li&gt;13 bits correspondent au champ &lt;strong&gt;Position Fragment&lt;/strong&gt;. Ce champ
indique la position du fragment par rapport au premier
datagramme et interviendra lors de la reconstitution du
message.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Le 9ème octet contient le TTL (Time to Live).&lt;/strong&gt; ‘Durée de vie’ en
français. Il indique le nombre maximal de routeurs que peut traverser
le datagramme. Il est initialisé par la station émettrice et
décrémenté de 1 par chaque routeur qui reçoit le datagramme et le
réexpédie. Si un routeur reçoit un datagramme dont le TTL est nul, il
le détruit et renvoie à l’expéditeur un message ICMP. Le but de ce
champ est d’éviter les paquets fantômes qui circuleraient en boucle
sur le réseau sans atteindre leur destination.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pour la petite histoire, c’est de cette manière que fonctionne
l’application &lt;strong&gt;traceroute&lt;/strong&gt;. Lorsqu’on lance traceroute
&lt;a class="reference external" href="http://www.devarieux.net"&gt;www.devarieux.net&lt;/a&gt;, traceroute envoie
un ping vers www.devarieux.net avec un TTL de 1. Lorsque le premier
routeur reçoit le paquet, il le détruit et renvoie à l’expediteur un
message ICMP l’informant que le paquet a été détruit (time to live
exceeded). Ce message ICMP contient dans son en-tête l’adresse IP du
routeur. Suite à cela, traceroute recommence l’opération mais avec
un TTL de 2 et ainsi de suite jusqu’à toucher www.aldevar.fr. Et
c’est de cette manière qu’on obtient la route prise par notre
paquet. Attention ceci dit car 2 paquets envoyés vers la même
destination peuvent emprunter des routes différentes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Le 10ème octet sert à coder le protocole&lt;/strong&gt; qui se trouve dans les
données qui suivent l’en-tête. Il est codé sur 8 bits. Les protocoles
les plus communs sont ICMP (0000.0001), TCP (0000.0110) et UDP
(0001.0001).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;11ème et 12ème octets : Le checksum&lt;/strong&gt;. C’est la somme de contrôle
de l’en-tête du datagramme. Chaque machine qui reçoit le paquet doit
recalculer ce checksum car la modification du TTL modifie celui ci.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Les octets 13 à 16 contiennent l’&lt;strong&gt;adresse IP de la machine
émétrice&lt;/strong&gt;. C’est également l’adresse de réponse.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Et enfin les 4 derniers octets contiennent eux l’&lt;strong&gt;adresse IP de
destination&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="capture-de-trame"&gt;
&lt;h2&gt;Capture de trame&lt;/h2&gt;
&lt;p&gt;Puisqu’il n’est pas particulièrement évident pour nous, simples mortels,
de lire ces bits pour comprendre ce que contient le datagramme, on peut
utiliser un logiciel de capture de trame tel que &lt;strong&gt;wireshark&lt;/strong&gt; en mode
graphique ou &lt;strong&gt;tcpdump&lt;/strong&gt; en mode commande. Je vous laisse vous même
découvrir ces applications. Je vais me contenter ici de montrer un
screenshot d’une capture faite avec wireshark qui montre ce que ce
logiciel peut nous dire sur le contenu de nos paquets.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="/images/trame01.png"&gt;&lt;img alt="trame01" src="/images/trame01.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Voici le type de paquet que nous avons capturé. C’est un
simple ping entre 2 machines se situant sur des réseaux différents.
Wireshark nous dit déjà que c’est un paquet ICMP. Voyons le détail de ce
datagramme :&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="/images/trame02.png"&gt;&lt;img alt="trame02" src="/images/trame02.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;En dépliant le contenu de l’en-tête IP, voici ce que wireshark peut nous
dire :&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Nous sommes en IPv4.&lt;/li&gt;
&lt;li&gt;Le header fait 20 octets (bytes et non bits).&lt;/li&gt;
&lt;li&gt;La longueur total du datagramme est de 60 octets. On en conclue donc
que nous avons 40 octets de données.&lt;/li&gt;
&lt;li&gt;Le message n’est pas fragmenté.&lt;/li&gt;
&lt;li&gt;Le TTL est de 128 ce qui signifie qu’après avoir traversé 128
routeurs, le paquet sera détruit.&lt;/li&gt;
&lt;li&gt;Le protocole contenu dans les data est ICMP&lt;/li&gt;
&lt;li&gt;Le checksum est correct.&lt;/li&gt;
&lt;li&gt;Enfin, à la fin, les IP de départ et de destination.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Voilà, c’est terminé pour l’analyse de paquet de niveau 3. La prochaine
fois, j’essaierai d’expliquer le contenu d’un en-tête &amp;nbsp;de niveau 4
(couche transport : UDP, TCP etc…) ou de niveau 2 (couche liaison, trame
ethernet). Si vous trouvez que cet article manque de précision n’hésitez
pas à m’en faire part.&lt;/p&gt;
&lt;/div&gt;
</content><category term="QRQVB"></category></entry><entry><title>QRQVB : Le modèle OSI</title><link href="2009/08/qrqvb-le-modele-osi.html" rel="alternate"></link><published>2009-08-17T18:30:00+02:00</published><updated>2009-08-17T18:30:00+02:00</updated><author><name>aldevar</name></author><id>tag:None,2009-08-17:2009/08/qrqvb-le-modele-osi.html</id><summary type="html">&lt;p&gt;Dans cette nouvelle catégorie (la Question Réseau Qui Va Bien), je vous
propose de (re)découvrir avec moi, quelques notions fondamentales de
réseau. Ces articles s'adressent en particulier à ceux qui souhaitent
comprendre les mécanismes d'Internet et/ou du routage en&amp;nbsp;WAN&amp;nbsp;ou en&amp;nbsp;LAN.
J'essaierai d'être le plus clair …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Dans cette nouvelle catégorie (la Question Réseau Qui Va Bien), je vous
propose de (re)découvrir avec moi, quelques notions fondamentales de
réseau. Ces articles s'adressent en particulier à ceux qui souhaitent
comprendre les mécanismes d'Internet et/ou du routage en&amp;nbsp;WAN&amp;nbsp;ou en&amp;nbsp;LAN.
J'essaierai d'être le plus clair possible. Si vous trouvez des erreurs,
non-sens dans ces articles, je suis ouvert à toutes critiques,
corrections. Et pour inaugurer cette catégorie, commençons donc par le
modèle OSI, qui est la base pour une bonne compréhension des mécanismes
des réseaux informatiques.&lt;/p&gt;
&lt;div class="section" id="definition"&gt;
&lt;h2&gt;Définition&lt;/h2&gt;
&lt;p&gt;Le modèle OSI est une norme définie par l'ISO pour permettre
l'interconnexion des systèmes. Il propose un modèle d'architecture
réseau afin de s'assurer que tous les systèmes interconnectés puissent
communiquer entre eux quel que soit le constructeur du matériel. Les
constructeurs informatiques ont proposé des architectures réseaux
propres à leurs équipements. Par exemple, IBM a proposé SNA, DEC a
proposé DNA... Ces architectures ont toutes le même défaut : du fait de
leur caractère propriétaire, il n'est pas facile des les interconnecter,
à moins d'un accord entre constructeurs.&amp;nbsp;Le modèle OSI ne précise pas
vraiment les services et protocoles à utiliser pour chaque couches. Il
décrit plutôt ce que doivent faire ces couches. Je sais que ça ne parait
pas très clair pour le moment, mais ça va le devenir.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="schema-du-modele"&gt;
&lt;h2&gt;Schéma du modèle&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="images/modele_OSI.gif"&gt;&lt;img alt="modele_OSI" src="images/modele_OSI.gif" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Le modèle OSI est donc représenté en 7 couches distinctes. J'ai ici
représenté 2 machines (Système A et Système B) pour bien montrer que
lors de la communication de 2 hôtes, chaque couche 'discute' directement
avec la couche équivalente de l'hôte d'en face.&lt;/p&gt;
&lt;div class="section" id="couche-physique"&gt;
&lt;h3&gt;1°) Couche Physique&lt;/h3&gt;
&lt;p&gt;La couche physique s'occupe de la transmission des bits de façon brute
sur un canal de communication. Plus clairement, elle est typiquement
représentée par votre carte réseau et sa prise ethernet (et non pas le
protocole ethernet!!).&amp;nbsp;La couche phyique discute directement avec l'hôte
suivant sur le réseau. C'est à dire que lors d'une communication sur
internet, cette couche ne s'occupe de l'envoie des données que vers la
machine suivante, en général un routeur.&amp;nbsp;La couche physique traite
exclusivement avec des bits 0 et 1 et normalise l'écriture de ces bits
(une tension de 5V corespond à un 1, -5V un 0).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="couche-liaison"&gt;
&lt;h3&gt;2°) Couche Liaison&lt;/h3&gt;
&lt;p&gt;La couche de liaison (ou liaison de donnée) est un liant entre les 2
couches physiques des hôtes en communications. Elle fractionne les
données en trames et tente d'exempter la couche physique des erreurs de
transmissions. Elle doit être capable de renvoyer une trame lorsqu'il y
a un problème sur la ligne et intègre également un système de gestion de
flux pour éviter les engorgements. Par exemple une carte 100Mb/s relié à
une carte 1Gb/S doivent pouvoir communiquer sans que la carte 100Mb/s
recoive 10x trop de données.&amp;nbsp;L'unité d'information de cette couche est
donc la trame qui est composé de quelques centaines d'octets.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="couche-reseau"&gt;
&lt;h3&gt;3°) Couche Réseau&lt;/h3&gt;
&lt;p&gt;La couche réseau construit la liaison de bout en bout lors de la
communication de 2 hôtes. C'est la seule couche directement concernée
par la topologie du réseau. Elle va trouver la route parmis les routeurs
pour atteindre l'hôte cible.&amp;nbsp;Lors d'un envoie de données, 2 paquets
différents peuvent emprunter des routes différentes suivant
l'architecture du réseau et ses point d'engorgement.&amp;nbsp;C'est la dernière
couche supportée par TOUTES les machines du réseau (hôtes, switchs,
routeurs, serveurs). Son unité d'information est le paquet.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="couche-transport"&gt;
&lt;h3&gt;4°) Couche Transport&lt;/h3&gt;
&lt;p&gt;Cette couche est responsable du bon acheminement des messages complets
au destinataire. Le rôle principal de la couche transport est de prendre
les messages de la couche session, de les découper s'il le faut en
unités plus petites et de les passer à la couche réseau et inversement
du coté du recepteur.&amp;nbsp;Comme on l'a vu dans la couche réseau, 2 paquets
d'un même message peuvent prendre des routes différentes et donc arriver
dans le désordre. Le rôle de la couche transport est donc de remettre
ces paquets dans l'ordre. Elle peut aussi gérer le multiplexage lors de
communications multiples entre 2 mêmes hôtes (par exemple une connexion
http et ftp sur le même canal).&amp;nbsp;Son unité d'information est le message.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="couche-session"&gt;
&lt;h3&gt;5°) Couche Session&lt;/h3&gt;
&lt;p&gt;Le service principale de la couche session est la synchronisation des
communications. Qui veut parler? Qui parle? Elle permet aussi de prendre
des 'snapshots' des flots de données pour pouvoir reprendre le dialogue
là où il en était avant une coupure du canal de communication.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="couche-presentation"&gt;
&lt;h3&gt;6°) Couche Présentation&lt;/h3&gt;
&lt;p&gt;La couche présentation est chargée du codage des données de la couche
application. En effet, toutes les couches plus basses transportent des
octets sans chercher comprendre leur signification. Ici, elle va
s'occuper d'encoder du texte, des images, de la video, de la voix etc...
en données transportables, c'est à dire en octet.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="couche-application"&gt;
&lt;h3&gt;7°) Couche Application&lt;/h3&gt;
&lt;p&gt;Cette couche est le point de contact entre l'utilisateur et le réseau.
Elle lui apporte l'interface lui permettant de communiquer avec celui ci
(messagerie, http, ftp etc...).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="exemples-de-protocoles"&gt;
&lt;h2&gt;Exemples de protocoles&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Physique → biphase, bipolaire simple&lt;/li&gt;
&lt;li&gt;Liaison → ATM, Ethernet, PPP, TokenRing, Fiber Distributed Date
Interface (FDDI)&lt;/li&gt;
&lt;li&gt;Réseau → IP, IPX, ICMP&lt;/li&gt;
&lt;li&gt;Transport → TCP, UDP (pour les plus connus)&lt;/li&gt;
&lt;li&gt;Session → SIP, Appletalk&lt;/li&gt;
&lt;li&gt;Présentation → ASCII, Unicode, ASN.1, Videotex&lt;/li&gt;
&lt;li&gt;Application → HTTP, SMTP, POP, FTP, DNS, SNMP&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content><category term="QRQVB"></category><category term="osi"></category><category term="qrqvb"></category><category term="réseaux"></category></entry></feed>